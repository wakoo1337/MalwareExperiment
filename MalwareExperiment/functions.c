#include <windows.h>
#include <bcrypt.h>
#include "functions.h"

#ifdef NDEBUG
void* malloc(size_t size) {
	return HeapAlloc(GetProcessHeap(), 0, size);
};
void free(void* buffer) {
	HeapFree(GetProcessHeap(), 0, buffer);
};
void* realloc(void* buffer, size_t new_size) {
	return HeapReAlloc(GetProcessHeap(), 0, buffer, new_size);
};

#define MAX(a,b) ((a)>(b)?(a):(b))
#define MIN(a,b) ((a)<(b)?(a):(b))

wchar_t* wcschr(const wchar_t* s, wchar_t c)
{
	if (!c) return (wchar_t*)s + wcslen_wrapper(s);
	for (; *s && *s != c; s++);
	return *s ? (wchar_t*)s : 0;
}

wchar_t* wmemchr(const wchar_t* s, wchar_t c, size_t n)
{
	for (; n && *s != c; n--, s++);
	return n ? (wchar_t*)s : 0;
}

int wmemcmp(const wchar_t* l, const wchar_t* r, size_t n)
{
	for (; n && *l == *r; n--, l++, r++);
	return n ? (*l < *r ? -1 : *l > *r) : 0;
}

static wchar_t* twoway_wcsstr(const wchar_t* h, const wchar_t* n)
{
	const wchar_t* z;
	size_t l, ip, jp, k, p, ms, p0, mem, mem0;

	/* Computing length of needle */
	for (l = 0; n[l] && h[l]; l++);
	if (n[l]) return 0; /* hit the end of h */

	/* Compute maximal suffix */
	ip = -1; jp = 0; k = p = 1;
	while (jp + k < l) {
		if (n[ip + k] == n[jp + k]) {
			if (k == p) {
				jp += p;
				k = 1;
			}
			else k++;
		}
		else if (n[ip + k] > n[jp + k]) {
			jp += k;
			k = 1;
			p = jp - ip;
		}
		else {
			ip = jp++;
			k = p = 1;
		}
	}
	ms = ip;
	p0 = p;

	/* And with the opposite comparison */
	ip = -1; jp = 0; k = p = 1;
	while (jp + k < l) {
		if (n[ip + k] == n[jp + k]) {
			if (k == p) {
				jp += p;
				k = 1;
			}
			else k++;
		}
		else if (n[ip + k] < n[jp + k]) {
			jp += k;
			k = 1;
			p = jp - ip;
		}
		else {
			ip = jp++;
			k = p = 1;
		}
	}
	if (ip + 1 > ms + 1) ms = ip;
	else p = p0;

	/* Periodic needle? */
	if (wmemcmp(n, n + p, ms + 1)) {
		mem0 = 0;
		p = MAX(ms, l - ms - 1) + 1;
	}
	else mem0 = l - p;
	mem = 0;

	/* Initialize incremental end-of-haystack pointer */
	z = h;

	/* Search loop */
	for (;;) {
		/* Update incremental end-of-haystack pointer */
		if (z - h < l) {
			/* Fast estimate for MIN(l,63) */
			size_t grow = l | 63;
			const wchar_t* z2 = wmemchr(z, 0, grow);
			if (z2) {
				z = z2;
				if (z - h < l) return 0;
			}
			else z += grow;
		}

		/* Compare right half */
		for (k = MAX(ms + 1, mem); n[k] && n[k] == h[k]; k++);
		if (n[k]) {
			h += k - ms;
			mem = 0;
			continue;
		}
		/* Compare left half */
		for (k = ms + 1; k > mem && n[k - 1] == h[k - 1]; k--);
		if (k <= mem) return (wchar_t*)h;
		h += p;
		mem = mem0;
	}
}

wchar_t* wcsstr(const wchar_t* restrict h, const wchar_t* restrict n)
{
	/* Return immediately on empty needle or haystack */
	if (!n[0]) return (wchar_t*)h;
	if (!h[0]) return 0;

	/* Use faster algorithms for short needles */
	h = wcschr(h, *n);
	if (!h || !n[1]) return (wchar_t*)h;
	if (!h[1]) return 0;

	return twoway_wcsstr(h, n);
}

wchar_t* wmemcpy(wchar_t* restrict d, const wchar_t* restrict s, size_t n)
{
	wchar_t* a = d;
	while (n--) *d++ = *s++;
	return a;
}

wchar_t* _wcsdup(const wchar_t* s)
{
	size_t l = wcslen_wrapper(s);
	wchar_t* d = malloc((l + 1) * sizeof(wchar_t));
	if (!d) return NULL;
	return wmemcpy(d, s, l + 1);
}

errno_t rand_s(unsigned int* p) {
	return BCryptGenRandom(NULL, (unsigned char *) p, sizeof(unsigned int), BCRYPT_USE_SYSTEM_PREFERRED_RNG);
};

void* musl_memcpy(void* restrict dest, const void* restrict src, size_t n)
{
	unsigned char* d = dest;
	const unsigned char* s = src;

	for (; n; n--) *d++ = *s++;
	return dest;
}

void* musl_memset(void* dest, int c, size_t n)
{
	unsigned char* s = dest;
	size_t k;

	/* Fill head and tail with minimal branching. Each
	 * conditional ensures that all the subsequently used
	 * offsets are well-defined and in the dest region. */

	if (!n) return dest;
	s[0] = c;
	s[n - 1] = c;
	if (n <= 2) return dest;
	s[1] = c;
	s[2] = c;
	s[n - 2] = c;
	s[n - 3] = c;
	if (n <= 6) return dest;
	s[3] = c;
	s[n - 4] = c;
	if (n <= 8) return dest;

	/* Advance pointer to align it at a 4-byte boundary,
	 * and truncate n to a multiple of 4. The previous code
	 * already took care of any head/tail that get cut off
	 * by the alignment. */

	k = -(uintptr_t)s & 3;
	s += k;
	n -= k;
	n &= -4;

	/* Pure C fallback with no aliasing violations. */
	for (; n; n--, s++) *s = c;

	return dest;
}

int musl_wcscmp(const wchar_t* l, const wchar_t* r)
{
	for (; *l == *r && *l && *r; l++, r++);
	return *l < *r ? -1 : *l > *r;
}

void* memcpy_wrapper(void* restrict dest, const void* restrict src, size_t n) {
	return musl_memcpy(dest, src, n);
}

void* memset_wrapper(void* dest, int c, size_t n) {
	return musl_memset(dest, c, n);
}

int wcscmp_wrapper(const wchar_t* l, const wchar_t* r) {
	return musl_wcscmp(l, r);
}

size_t musl_wcslen(const wchar_t* s)
{
	const wchar_t* a;
	for (a = s; *s; s++);
	return s - a;
}

size_t wcslen_wrapper(const wchar_t* s) {
	return musl_wcslen(s);
}

#else

void* memcpy_wrapper(void* restrict dest, const void* restrict src, size_t n) {
	return memcpy(dest, src, n);
}

void* memset_wrapper(void* dest, int c, size_t n) {
	return memset(dest, c, n);
}

int wcscmp_wrapper(const wchar_t* l, const wchar_t* r) {
	return wcscmp(l, r);
}

size_t wcslen_wrapper(const wchar_t* s) {
	return wcslen(s);
}

#endif