#define _CRT_RAND_S
#include <stdlib.h>
#include <Windows.h>
#include <wincodec.h>
#include "resource.h"
#include <malloc.h>
#include "screamer_control.h"
#include "ScreamerPicture.h"
#include "ScreamerStruct.h"
#include "getRequiredScreamerStatus.h"
#include "loadJpegResource.h"

#include "screamerWndProc.h"
LRESULT screamerWndProc(HWND hWnd, UINT uInt, WPARAM wParam, LPARAM lParam) {
#define TIMER_SHOW 10002
#define TIMER_HIDE 10003
#define PERIOD 2000
#define SHOW_TIME 500
	struct ScreamerStruct* screamer_data;
	screamer_data = (struct ScreamerStruct*)GetWindowLongPtrW(hWnd, GWLP_USERDATA);
	switch (uInt) {
	case WM_CREATE:
		screamer_data = malloc(sizeof(struct ScreamerStruct));
		if (screamer_data) {
			*screamer_data = (struct ScreamerStruct){ 0 };
			SetWindowLongPtrW(hWnd, GWLP_USERDATA, (LONG_PTR)screamer_data);
			static const int screamer_resources[PICTURES_COUNT] = { IDR_CREEPY1, IDR_CREEPY2, IDR_CREEPY3, IDR_CREEPY4, IDR_CREEPY5, IDR_CREEPY6, IDR_CREEPY7, IDR_CREEPY8 };
			IWICImagingFactory* factory;
			if (SUCCEEDED(CoCreateInstance(&CLSID_WICImagingFactory, NULL, CLSCTX_ALL, &IID_IWICImagingFactory, &factory))) {
				for (int j = 0; j < PICTURES_COUNT; j++) {
					screamer_data->pictures[j].bits = loadJpegResource(factory, screamer_resources[j], &(screamer_data->pictures[j].info_hdr));
					if (!screamer_data->pictures[j].bits) {
						for (int i = 0; i < j; i++) {
							free(screamer_data->pictures[j].bits);
							factory->lpVtbl->Release(factory);
						}
						free(screamer_data);
						return -1;
					};
					screamer_data->status = getRequiredScreamerStatus();
					if (screamer_data->status) {
						ShowWindow(hWnd, SW_NORMAL);
						SetTimer(hWnd, TIMER_HIDE, SHOW_TIME, NULL);
					};
				};
				factory->lpVtbl->Release(factory);
			}
			else {
				free(screamer_data);
				return -1;
			}
		}
		else return -1;
		break;
	case WM_DESTROY:
		for (int i = 0; i < PICTURES_COUNT; i++) free(screamer_data->pictures[i].bits);
		free(screamer_data);
		break;
	case WM_PAINT:
		PAINTSTRUCT ps;
		BeginPaint(hWnd, &ps);
		StretchDIBits(ps.hdc, 0, 0, screamer_data->pictures[screamer_data->index].info_hdr.biWidth, -screamer_data->pictures[screamer_data->index].info_hdr.biHeight, 0, 0, screamer_data->pictures[screamer_data->index].info_hdr.biWidth, -screamer_data->pictures[screamer_data->index].info_hdr.biHeight, screamer_data->pictures[screamer_data->index].bits, (BITMAPINFO*)&(screamer_data->pictures[screamer_data->index].info_hdr), DIB_RGB_COLORS, SRCCOPY);
		EndPaint(hWnd, &ps);
		break;
	case WM_COMMAND:
		if (wParam == SCREAMER_ENABLE) {
			if (!screamer_data->status) {
				ShowWindow(hWnd, SW_NORMAL);
				SetTimer(hWnd, TIMER_HIDE, SHOW_TIME, NULL);
				KillTimer(hWnd, TIMER_SHOW);
				screamer_data->status = TRUE;
			}
		}
		else if (wParam == SCREAMER_DISABLE) {
			if (screamer_data->status) {
				ShowWindow(hWnd, SW_HIDE);
				KillTimer(hWnd, TIMER_SHOW);
				KillTimer(hWnd, TIMER_HIDE);
				screamer_data->status = FALSE;
			}
		}
		break;
	case WM_TIMER:
		if (wParam == TIMER_SHOW) {
			rand_s(&(screamer_data->index));
			screamer_data->index %= PICTURES_COUNT;
			unsigned int x, y;
			rand_s(&x);
			rand_s(&y);
			x %= (GetSystemMetrics(SM_CXSCREEN) - screamer_data->pictures[screamer_data->index].info_hdr.biWidth);
			y %= (GetSystemMetrics(SM_CYSCREEN) + screamer_data->pictures[screamer_data->index].info_hdr.biHeight);
			SetWindowPos(hWnd, HWND_TOPMOST, x, y, screamer_data->pictures[screamer_data->index].info_hdr.biWidth, -(screamer_data->pictures[screamer_data->index].info_hdr.biHeight), SWP_NOACTIVATE | SWP_SHOWWINDOW);
			ShowWindow(hWnd, SW_NORMAL);
			UpdateWindow(hWnd);
			KillTimer(hWnd, TIMER_SHOW);
			SetTimer(hWnd, TIMER_HIDE, SHOW_TIME, NULL);
		}
		else if (wParam == TIMER_HIDE) {
			ShowWindow(hWnd, SW_HIDE);
			KillTimer(hWnd, TIMER_HIDE);
			SetTimer(hWnd, TIMER_SHOW, PERIOD - SHOW_TIME, NULL);
		}
		break;
	default:
		return DefWindowProcW(hWnd, uInt, wParam, lParam);
		break;
	};
	return 0;
};